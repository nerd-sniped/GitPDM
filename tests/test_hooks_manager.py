"""
Tests for Hooks Manager (Sprint 2)
"""

import pytest
import tempfile
import subprocess
from pathlib import Path

from freecad.gitpdm.git.hooks_manager import HooksManager


class TestHooksManagerBasic:
    """Test basic hooks manager operations."""
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary git repository."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            yield repo
    
    def test_init_hooks_manager(self, temp_repo):
        """Test creating hooks manager."""
        manager = HooksManager(temp_repo)
        assert manager.repo_root == temp_repo
        assert manager.hooks_dir == temp_repo / '.git' / 'hooks'
    
    def test_hooks_dir_exists(self, temp_repo):
        """Test hooks directory exists after git init."""
        manager = HooksManager(temp_repo)
        assert manager.hooks_dir.exists()


class TestHookInstallation:
    """Test hook installation operations."""
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary git repository."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            yield repo
    
    def test_install_single_hook(self, temp_repo):
        """Test installing a single hook."""
        manager = HooksManager(temp_repo)
        
        result = manager.install_hook('pre-commit')
        
        assert result.ok
        hook_path = temp_repo / '.git' / 'hooks' / 'pre-commit'
        assert hook_path.exists()
        
        # Check hook content
        content = hook_path.read_text()
        assert 'Generated by GitPDM Sprint 2' in content
        assert 'from freecad.gitpdm.git.hooks import pre_commit_hook' in content
    
    def test_install_hook_twice_without_force(self, temp_repo):
        """Test installing hook twice fails without force."""
        manager = HooksManager(temp_repo)
        
        # First install
        result1 = manager.install_hook('pre-commit')
        assert result1.ok
        
        # Second install without force should fail
        result2 = manager.install_hook('pre-commit', force=False)
        assert not result2.ok
    
    def test_install_hook_with_force(self, temp_repo):
        """Test installing hook with force overwrites."""
        manager = HooksManager(temp_repo)
        
        # First install
        manager.install_hook('pre-commit')
        
        # Second install with force
        result = manager.install_hook('pre-commit', force=True)
        assert result.ok
    
    def test_install_all_hooks(self, temp_repo):
        """Test installing all hooks at once."""
        manager = HooksManager(temp_repo)
        
        result = manager.install_all_hooks()
        
        # Result should be success
        assert result.ok
        results = result.value
        
        # All hooks should be installed
        assert len(results) == 5  # pre-commit, post-checkout, post-merge, post-rewrite, pre-push
        
        for hook_name in results:
            hook_path = temp_repo / '.git' / 'hooks' / hook_name
            assert hook_path.exists()
    
    def test_install_invalid_hook(self, temp_repo):
        """Test installing invalid hook name."""
        manager = HooksManager(temp_repo)
        
        result = manager.install_hook('invalid-hook')
        assert not result.ok


class TestHookUninstallation:
    """Test hook uninstallation operations."""
    
    @pytest.fixture
    def temp_repo_with_hooks(self):
        """Create repository with hooks installed."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            
            # Install hooks
            manager = HooksManager(repo)
            manager.install_all_hooks()
            
            yield repo
    
    def test_uninstall_single_hook(self, temp_repo_with_hooks):
        """Test uninstalling a single hook."""
        manager = HooksManager(temp_repo_with_hooks)
        
        hook_path = temp_repo_with_hooks / '.git' / 'hooks' / 'pre-commit'
        assert hook_path.exists()
        
        result = manager.uninstall_hook('pre-commit')
        
        assert result.ok
        assert not hook_path.exists()
    
    def test_uninstall_all_hooks(self, temp_repo_with_hooks):
        """Test uninstalling all hooks."""
        manager = HooksManager(temp_repo_with_hooks)
        
        result = manager.uninstall_all_hooks()
        
        assert result.ok
        results = result.value
        
        assert len(results) == 5
        for hook_name in results:
            hook_path = temp_repo_with_hooks / '.git' / 'hooks' / hook_name
            assert not hook_path.exists()
    
    def test_uninstall_non_gitpdm_hook(self, temp_repo_with_hooks):
        """Test uninstalling hook not installed by GitPDM."""
        manager = HooksManager(temp_repo_with_hooks)
        
        # Replace hook with non-GitPDM hook
        hook_path = temp_repo_with_hooks / '.git' / 'hooks' / 'pre-commit'
        hook_path.write_text("#!/bin/sh\necho 'Custom hook'")
        
        result = manager.uninstall_hook('pre-commit')
        
        # Should not remove non-GitPDM hook
        assert not result.ok
        assert hook_path.exists()


class TestHookStatus:
    """Test hook status queries."""
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary git repository."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            yield repo
    
    def test_is_hook_installed_false(self, temp_repo):
        """Test checking if hook is installed when not."""
        manager = HooksManager(temp_repo)
        
        assert not manager.is_hook_installed('pre-commit')
    
    def test_is_hook_installed_true(self, temp_repo):
        """Test checking if hook is installed when it is."""
        manager = HooksManager(temp_repo)
        manager.install_hook('pre-commit')
        
        assert manager.is_hook_installed('pre-commit')
    
    def test_get_hook_status_none_installed(self, temp_repo):
        """Test getting status when no hooks installed."""
        manager = HooksManager(temp_repo)
        
        status = manager.get_hook_status()
        
        assert len(status) == 5
        for hook_name, installed in status.items():
            assert not installed
    
    def test_get_hook_status_some_installed(self, temp_repo):
        """Test getting status when some hooks installed."""
        manager = HooksManager(temp_repo)
        
        # Install only pre-commit and post-checkout
        manager.install_hook('pre-commit')
        manager.install_hook('post-checkout')
        
        status = manager.get_hook_status()
        
        assert status['pre-commit'] is True
        assert status['post-checkout'] is True
        assert status['post-merge'] is False
        assert status['post-rewrite'] is False
        assert status['pre-push'] is False
    
    def test_get_hook_status_all_installed(self, temp_repo):
        """Test getting status when all hooks installed."""
        manager = HooksManager(temp_repo)
        manager.install_all_hooks()
        
        status = manager.get_hook_status()
        
        for hook_name, installed in status.items():
            assert installed


class TestHookExecution:
    """Test that installed hooks are executable."""
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary git repository."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            subprocess.run(['git', 'config', 'user.name', 'Test User'], cwd=repo)
            subprocess.run(['git', 'config', 'user.email', 'test@example.com'], cwd=repo)
            
            # Create config directory
            config_dir = repo / "FreeCAD_Automation"
            config_dir.mkdir()
            (config_dir / "config.json").write_text("""{
                "uncompressed-directory-structure": {
                    "uncompressed-directory-suffix": "_uncompressed",
                    "uncompressed-directory-prefix": "",
                    "subdirectory": {"put-uncompressed-directory-in-subdirectory": false, "subdirectory-name": ""}
                },
                "compress-non-human-readable-FreeCAD-files": {
                    "enabled": false, "files-to-compress": [], "max-compressed-file-size-gigabyte": 2.0,
                    "compression-level": 6, "zip-file-prefix": "binaries_"
                },
                "require-lock-to-modify-FreeCAD-files": false,
                "include-thumbnails": true
            }""")
            
            yield repo
    
    def test_hook_is_executable_unix(self, temp_repo):
        """Test hook file permissions on Unix systems."""
        import sys
        if sys.platform == 'win32':
            pytest.skip("Unix-only test")
        
        manager = HooksManager(temp_repo)
        manager.install_hook('pre-commit')
        
        hook_path = temp_repo / '.git' / 'hooks' / 'pre-commit'
        
        # Check executable bit
        import stat
        mode = hook_path.stat().st_mode
        assert mode & stat.S_IXUSR  # User execute permission
    
    @pytest.mark.skip(reason="Integration test - requires proper Python path in git hooks")
    @pytest.mark.integration
    def test_hook_executes_via_git(self, temp_repo):
        """Test that git can execute the installed hook."""
        manager = HooksManager(temp_repo)
        manager.install_hook('pre-commit')
        
        # Create an empty FCStd file (should pass pre-commit)
        (temp_repo / "test.FCStd").write_bytes(b'')
        
        # Try to commit
        subprocess.run(['git', 'add', '.'], cwd=temp_repo)
        result = subprocess.run(
            ['git', 'commit', '-m', 'Test commit'],
            cwd=temp_repo,
            capture_output=True,
            text=True
        )
        
        # Should succeed (hook passes)
        assert result.returncode == 0


class TestConvenienceFunctions:
    """Test convenience functions."""
    
    @pytest.fixture
    def temp_repo(self):
        """Create a temporary git repository."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            subprocess.run(['git', 'init'], cwd=repo, capture_output=True)
            yield repo
    
    def test_install_hooks_in_repo(self, temp_repo):
        """Test convenience function to install hooks."""
        from freecad.gitpdm.git.hooks_manager import install_hooks_in_repo
        
        result = install_hooks_in_repo(temp_repo)
        
        assert result.ok
        results = result.value
        assert len(results) == 5
    
    def test_uninstall_hooks_from_repo(self, temp_repo):
        """Test convenience function to uninstall hooks."""
        from freecad.gitpdm.git.hooks_manager import (
            install_hooks_in_repo,
            uninstall_hooks_from_repo
        )
        
        # Install first
        install_hooks_in_repo(temp_repo)
        
        # Then uninstall
        result = uninstall_hooks_from_repo(temp_repo)
        
        assert result.ok
        results = result.value
        assert len(results) == 5


class TestEdgeCases:
    """Test edge cases and error handling."""
    
    def test_manager_with_non_git_repo(self):
        """Test manager with directory that's not a git repo."""
        with tempfile.TemporaryDirectory() as tmpdir:
            repo = Path(tmpdir)
            
            # Creating manager should raise ValueError
            with pytest.raises(ValueError, match="Not a git repository"):
                HooksManager(repo)
    
    def test_manager_with_non_existent_path(self):
        """Test manager with path that doesn't exist."""
        repo = Path("/non/existent/path")
        
        # Creating manager should raise ValueError
        with pytest.raises(ValueError, match="Not a git repository"):
            HooksManager(repo)
