# -*- coding: utf-8 -*-
"""
Git Hooks Manager - Sprint 2
Manages installation, removal, and execution of Python-based git hooks.
"""

from __future__ import annotations

import sys
import subprocess
from pathlib import Path
from typing import Optional

from freecad_gitpdm.core import log
from freecad_gitpdm.core.result import Result


# Hook script template for installed hooks
HOOK_SCRIPT_TEMPLATE = '''#!/usr/bin/env python3
"""
Auto-generated git hook - calls Python hook implementation.
Generated by GitPDM Sprint 2 hooks manager.
"""
import sys
from pathlib import Path

# Add GitPDM to path
repo_root = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(repo_root))

try:
    from freecad_gitpdm.git.hooks import {hook_function}
    exit_code = {hook_function}(repo_root, *sys.argv[1:])
    sys.exit(exit_code)
except Exception as e:
    print(f"Hook execution failed: {{e}}", file=sys.stderr)
    sys.exit(1)
'''


class HooksManager:
    """Manages installation and removal of git hooks."""
    
    # Map of hook names to their Python function names
    HOOK_FUNCTIONS = {
        'pre-commit': 'pre_commit_hook',
        'post-checkout': 'post_checkout_hook',
        'post-merge': 'post_merge_hook',
        'post-rewrite': 'post_rewrite_hook',
        'pre-push': 'pre_push_hook',
    }
    
    def __init__(self, repo_root: Path):
        """
        Initialize hooks manager for a repository.
        
        Args:
            repo_root: Path to repository root
        """
        self.repo_root = Path(repo_root)
        self.git_dir = self.repo_root / '.git'
        self.hooks_dir = self.git_dir / 'hooks'
        
        if not self.git_dir.exists():
            raise ValueError(f"Not a git repository: {repo_root}")
    
    def install_hook(self, hook_name: str, force: bool = False) -> Result:
        """
        Install a Python-based git hook.
        
        Args:
            hook_name: Name of hook (e.g., 'pre-commit')
            force: Overwrite existing hook if True
            
        Returns:
            Result indicating success or failure
        """
        if hook_name not in self.HOOK_FUNCTIONS:
            return Result.failure(
                "INVALID_HOOK",
                f"Unknown hook: {hook_name}. Valid hooks: {list(self.HOOK_FUNCTIONS.keys())}"
            )
        
        # Create hooks directory if needed
        self.hooks_dir.mkdir(parents=True, exist_ok=True)
        
        hook_path = self.hooks_dir / hook_name
        
        # Check if hook already exists
        if hook_path.exists() and not force:
            return Result.failure(
                "HOOK_EXISTS",
                f"Hook {hook_name} already exists. Use force=True to overwrite."
            )
        
        # Generate hook script
        function_name = self.HOOK_FUNCTIONS[hook_name]
        hook_script = HOOK_SCRIPT_TEMPLATE.format(hook_function=function_name)
        
        try:
            # Write hook file
            hook_path.write_text(hook_script, encoding='utf-8')
            
            # Make executable on Unix systems
            if sys.platform != 'win32':
                hook_path.chmod(0o755)
            
            log.info(f"Installed {hook_name} hook at {hook_path}")
            return Result.success(hook_path)
            
        except Exception as e:
            log.error(f"Failed to install {hook_name} hook: {e}")
            return Result.failure("INSTALL_ERROR", f"Failed to install hook: {e}")
    
    def install_all_hooks(self, force: bool = False) -> Result:
        """
        Install all GitPDM hooks.
        
        Args:
            force: Overwrite existing hooks if True
            
        Returns:
            Result with dict of installed hooks
        """
        results = {}
        failed = []
        
        for hook_name in self.HOOK_FUNCTIONS:
            result = self.install_hook(hook_name, force=force)
            results[hook_name] = result.ok
            
            if not result.ok:
                failed.append(hook_name)
                log.warning(f"Failed to install {hook_name}: {result.error}")
        
        if failed:
            return Result.failure(
                "PARTIAL_INSTALL",
                f"Failed to install hooks: {', '.join(failed)}"
            )
        
        log.info(f"Installed all {len(self.HOOK_FUNCTIONS)} hooks")
        return Result.success(results)
    
    def uninstall_hook(self, hook_name: str) -> Result:
        """
        Uninstall a git hook.
        
        Args:
            hook_name: Name of hook to remove
            
        Returns:
            Result indicating success or failure
        """
        if hook_name not in self.HOOK_FUNCTIONS:
            return Result.failure(
                "INVALID_HOOK",
                f"Unknown hook: {hook_name}"
            )
        
        hook_path = self.hooks_dir / hook_name
        
        if not hook_path.exists():
            return Result.failure(
                "HOOK_NOT_FOUND",
                f"Hook {hook_name} is not installed"
            )
        
        try:
            # Check if it's our hook (contains our marker)
            content = hook_path.read_text()
            if "Generated by GitPDM Sprint 2" not in content:
                return Result.failure(
                    "NOT_GITPDM_HOOK",
                    f"Hook {hook_name} was not installed by GitPDM"
                )
            
            hook_path.unlink()
            log.info(f"Uninstalled {hook_name} hook")
            return Result.success(None)
            
        except Exception as e:
            log.error(f"Failed to uninstall {hook_name} hook: {e}")
            return Result.failure("UNINSTALL_ERROR", f"Failed to uninstall hook: {e}")
    
    def uninstall_all_hooks(self) -> Result:
        """
        Uninstall all GitPDM hooks.
        
        Returns:
            Result with dict of uninstalled hooks
        """
        results = {}
        failed = []
        
        for hook_name in self.HOOK_FUNCTIONS:
            result = self.uninstall_hook(hook_name)
            results[hook_name] = result.ok
            
            if not result.ok and result.error != "HOOK_NOT_FOUND":
                failed.append(hook_name)
                log.warning(f"Failed to uninstall {hook_name}: {result.error}")
        
        if failed:
            return Result.failure(
                "PARTIAL_UNINSTALL",
                f"Failed to uninstall hooks: {', '.join(failed)}"
            )
        
        log.info(f"Uninstalled all GitPDM hooks")
        return Result.success(results)
    
    def is_hook_installed(self, hook_name: str) -> bool:
        """
        Check if a hook is installed.
        
        Args:
            hook_name: Name of hook to check
            
        Returns:
            True if hook is installed and is a GitPDM hook
        """
        if hook_name not in self.HOOK_FUNCTIONS:
            return False
        
        hook_path = self.hooks_dir / hook_name
        
        if not hook_path.exists():
            return False
        
        try:
            content = hook_path.read_text()
            return "Generated by GitPDM Sprint 2" in content
        except Exception:
            return False
    
    def get_hook_status(self) -> dict:
        """
        Get installation status of all hooks.
        
        Returns:
            Dict mapping hook names to installation status
        """
        status = {}
        for hook_name in self.HOOK_FUNCTIONS:
            status[hook_name] = self.is_hook_installed(hook_name)
        return status


def install_hooks_in_repo(repo_root: Path, force: bool = False) -> Result:
    """
    Convenience function to install all hooks in a repository.
    
    Args:
        repo_root: Path to repository root
        force: Overwrite existing hooks if True
        
    Returns:
        Result indicating success or failure
    """
    try:
        manager = HooksManager(repo_root)
        return manager.install_all_hooks(force=force)
    except Exception as e:
        log.error(f"Failed to install hooks: {e}")
        return Result.failure("INSTALL_ERROR", f"Failed to install hooks: {e}")


def uninstall_hooks_from_repo(repo_root: Path) -> Result:
    """
    Convenience function to uninstall all hooks from a repository.
    
    Args:
        repo_root: Path to repository root
        
    Returns:
        Result indicating success or failure
    """
    try:
        manager = HooksManager(repo_root)
        return manager.uninstall_all_hooks()
    except Exception as e:
        log.error(f"Failed to uninstall hooks: {e}")
        return Result.failure("UNINSTALL_ERROR", f"Failed to uninstall hooks: {e}")


# CLI entry point for manual hook installation
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="GitPDM Hooks Manager")
    parser.add_argument("action", choices=["install", "uninstall", "status"],
                       help="Action to perform")
    parser.add_argument("--repo", default=".", help="Repository path (default: current directory)")
    parser.add_argument("--force", action="store_true", help="Force overwrite existing hooks")
    parser.add_argument("--hook", help="Specific hook name (optional)")
    
    args = parser.parse_args()
    
    repo_path = Path(args.repo).resolve()
    
    try:
        manager = HooksManager(repo_path)
        
        if args.action == "install":
            if args.hook:
                result = manager.install_hook(args.hook, force=args.force)
            else:
                result = manager.install_all_hooks(force=args.force)
            
            if result.ok:
                print(f"✓ Hooks installed successfully")
                sys.exit(0)
            else:
                print(f"✗ Failed to install hooks: {result.error}", file=sys.stderr)
                sys.exit(1)
        
        elif args.action == "uninstall":
            if args.hook:
                result = manager.uninstall_hook(args.hook)
            else:
                result = manager.uninstall_all_hooks()
            
            if result.ok:
                print(f"✓ Hooks uninstalled successfully")
                sys.exit(0)
            else:
                print(f"✗ Failed to uninstall hooks: {result.error}", file=sys.stderr)
                sys.exit(1)
        
        elif args.action == "status":
            status = manager.get_hook_status()
            print("GitPDM Hooks Status:")
            for hook_name, installed in status.items():
                symbol = "✓" if installed else "✗"
                status_text = "installed" if installed else "not installed"
                print(f"  {symbol} {hook_name}: {status_text}")
            sys.exit(0)
    
    except Exception as e:
        print(f"✗ Error: {e}", file=sys.stderr)
        sys.exit(1)
