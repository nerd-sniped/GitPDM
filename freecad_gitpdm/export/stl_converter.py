# -*- coding: utf-8 -*-
"""
Pure Python OBJ to STL converter (no external dependencies).

Converts Wavefront OBJ files to binary STL format for GitHub preview support.
Handles vertex/face parsing, normal computation, and deterministic binary output.
"""

import struct
from pathlib import Path
from typing import List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class Vector3:
    """3D vector for geometry calculations."""
    x: float
    y: float
    z: float

    def __sub__(self, other: 'Vector3') -> 'Vector3':
        return Vector3(self.x - other.x, self.y - other.y, self.z - other.z)

    def __add__(self, other: 'Vector3') -> 'Vector3':
        return Vector3(self.x + other.x, self.y + other.y, self.z + other.z)

    def __mul__(self, scalar: float) -> 'Vector3':
        return Vector3(self.x * scalar, self.y * scalar, self.z * scalar)

    def cross(self, other: 'Vector3') -> 'Vector3':
        """Compute cross product."""
        return Vector3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x,
        )

    def magnitude(self) -> float:
        """Compute vector length."""
        return (self.x ** 2 + self.y ** 2 + self.z ** 2) ** 0.5

    def normalize(self) -> 'Vector3':
        """Return normalized (unit) vector."""
        mag = self.magnitude()
        if mag < 1e-10:
            return Vector3(0.0, 0.0, 1.0)  # Degenerate; return default
        return Vector3(self.x / mag, self.y / mag, self.z / mag)

    def as_tuple(self) -> Tuple[float, float, float]:
        return (self.x, self.y, self.z)


@dataclass
class Triangle:
    """Triangle with vertices (indices into vertex list)."""
    v0: int
    v1: int
    v2: int


def parse_obj(obj_path: Path) -> Tuple[List[Vector3], List[Triangle], Optional[str]]:
    """
    Parse OBJ file and extract vertices and triangular faces.

    Returns:
        (vertices, triangles, error_msg)
        If error_msg is not None, parsing failed.
    """
    vertices: List[Vector3] = []
    triangles: List[Triangle] = []

    try:
        with obj_path.open("r", encoding="utf-8", errors="replace") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue

                parts = line.split()
                if not parts:
                    continue

                # Vertex: "v x y z"
                if parts[0] == "v" and len(parts) >= 4:
                    try:
                        x, y, z = float(parts[1]), float(parts[2]), float(parts[3])
                        vertices.append(Vector3(x, y, z))
                    except (ValueError, IndexError):
                        pass

                # Face: "f v1 v2 v3" or "f v1/vt1 v2/vt2 v3/vt3" or "f v1/vt1/vn1 ..."
                elif parts[0] == "f" and len(parts) >= 4:
                    try:
                        # Extract vertex indices (ignore texture/normal coords)
                        indices = []
                        for i in range(1, len(parts)):
                            vertex_part = parts[i].split("/")[0]
                            v_idx = int(vertex_part) - 1  # OBJ indices are 1-based
                            if 0 <= v_idx < len(vertices):
                                indices.append(v_idx)

                        # Triangulate: for n-gons, split into triangles from first vertex
                        if len(indices) >= 3:
                            for i in range(1, len(indices) - 1):
                                triangles.append(Triangle(indices[0], indices[i], indices[i + 1]))
                    except (ValueError, IndexError):
                        pass

    except Exception as e:
        return [], [], f"Failed to parse OBJ: {e}"

    if not vertices or not triangles:
        return [], [], "OBJ file has no vertices or faces"

    return vertices, triangles, None


def compute_normal(v0: Vector3, v1: Vector3, v2: Vector3) -> Vector3:
    """Compute face normal from three vertices using right-hand rule."""
    edge1 = v1 - v0
    edge2 = v2 - v0
    normal = edge1.cross(edge2)
    return normal.normalize()


def write_stl_binary(
    stl_path: Path,
    vertices: List[Vector3],
    triangles: List[Triangle],
) -> Optional[str]:
    """
    Write binary STL file.

    Binary STL format:
    - 80-byte header (binary, fixed at 80 bytes)
    - 4-byte uint32: triangle count
    - For each triangle:
      - 3 floats (12 bytes): face normal
      - 3 * (3 floats / 12 bytes): vertex 1, 2, 3
      - 2-byte uint16: attribute byte count (usually 0)

    Returns:
        error_msg if failed, None otherwise
    """
    try:
        with stl_path.open("wb") as f:
            # Header (EXACTLY 80 bytes)
            header_text = "Binary STL generated by GitPDM OBJ converter"
            header = header_text.encode("ascii")[:80]  # Truncate to 80 if too long
            header += b"\x00" * (80 - len(header))  # Pad with nulls to exactly 80
            assert len(header) == 80
            f.write(header)

            # Triangle count (4 bytes, little-endian uint32)
            f.write(struct.pack("<I", len(triangles)))

            # Write triangles
            for tri in triangles:
                # Get vertices
                v0 = vertices[tri.v0]
                v1 = vertices[tri.v1]
                v2 = vertices[tri.v2]

                # Compute normal
                normal = compute_normal(v0, v1, v2)

                # Write normal (3 floats)
                f.write(struct.pack("<fff", normal.x, normal.y, normal.z))

                # Write vertices (3 vertices * 3 floats each)
                f.write(struct.pack("<fff", v0.x, v0.y, v0.z))
                f.write(struct.pack("<fff", v1.x, v1.y, v1.z))
                f.write(struct.pack("<fff", v2.x, v2.y, v2.z))

                # Attribute byte count (2 bytes, usually 0)
                f.write(struct.pack("<H", 0))

        return None

    except Exception as e:
        return f"Failed to write STL: {e}"


def obj_to_stl(obj_path: Path, stl_path: Path) -> Optional[str]:
    """
    Convert OBJ file to binary STL.

    Args:
        obj_path: Path to input OBJ file
        stl_path: Path to output STL file

    Returns:
        error_msg if conversion failed, None on success
    """
    if not obj_path.exists():
        return f"OBJ file not found: {obj_path}"

    # Parse OBJ
    vertices, triangles, parse_err = parse_obj(obj_path)
    if parse_err:
        return parse_err

    # Write STL
    write_err = write_stl_binary(stl_path, vertices, triangles)
    if write_err:
        return write_err

    return None
